**Машина** состояний имеет двойственную структуру - помимо самих состояний имеются **анимации**, которые регулируют ход работы.

## Принцип работы:
- Хотим сменить состояние
- Вызываем проигрывание новой анимации: animatedSprite.Play(...)
- Ловим "запрос" в обработчике OnAnimationChanged()
- Вызываем состояние закрепленное за этой анимацией
- Вызывается обработчик Leave прошлого состояния
- Вызывается обработчик Enter нового состояния
- Состояние изменено.

```cpp
Условный стек вызовов:
#1: animatedSprite2D.Play(animationName)
#2: OnAnimationChanged(): 
	if (currentAnimation == animationName)
		dsm.ChangeState(newStateName);
#3: Leave(oldStateName);
#4: EnterState(newStateName) // вызывается единожды
#5: State(newStateName)      // вызывается каждый тик (PhysicsProcess реализация для конкретного состояния)
```

**Известная проблема** - это вызов асинхронный состояний, то есть асинхронный вызов проигрывания анимации.

Для предотвращения поломки анимаций и состояний введено правило:

**СИНХРОННЫЕ** функции-обработчики состояний имеют право спровоцировать смену состояния **ТОЛЬКО** в том случае, **ЕСЛИ** текущая анимация не является асинхронной.
**АСИНХРОННЫЕ** функции-обработчики состояний в конце цепочки своих вызовов **ОБЯЗАНЫ** спровоцировать смену состояния на **СИНХРОННОЕ** начальное (например *idle*).

Также как факт следует отметить, что синхронное **начальное** состояние в цепочке вызовов **ДОЛЖНО** уметь прийти к любому другому синхронному состоянию БЕЗ выполнения обработчиков в ходе цепочки вызовов.

То есть, в начале каждого состояния требуется проверять, нет ли факторов, которые сигнализируют о том, что текущее состояние должно быть иным.
